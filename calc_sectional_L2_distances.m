% This script will generate clips with two initial bounding boxes on
% patches. One patch will eventually occlude the other.

debug = false;

if_use_minus_something = false; % to use minus something frame instead of first to compare
compare_past_by = 20; % matter only if if_use_minus_something is true

pad = 100;

seqStart = 1;
seqEnd = 46;

if debug
    seqEnd = seqStart;
end

%%
for sNum = seqStart:seqEnd
    
    if mod(sNum, 10) == 1
        fprintf('\n');
    end
    fprintf('%02d ',sNum);
    
    seq_name = sprintf('self%05d',sNum);
    imDir = sprintf('/home/is/Occlusion Video Data/self shot/%s', seq_name);
    imageList = dir(fullfile(imDir, '*.jpg'));
    imFiles = {imageList.name};
    clear imageList;

%     [h, w, ~] = size(imread(fullfile(imDir,imFiles{1})));
    
    boxdir = fullfile(imDir,'bboxes');
    chunklist = dir(fullfile(boxdir, '*.box'));
    chunkfiles = {chunklist.name};
    clear chunklist;
    
    for chunk_i = 1:1:size(chunkfiles,2)
        
        % DEBUG; REMOVE LATER
        if chunk_i ~= 1 && debug
            continue;
        end
        
        [~,chunk_name,~] = fileparts(chunkfiles{chunk_i});
        
        minFrame = str2num(chunk_name(1:5));
        maxFrame = str2num(chunk_name(7:11));
        
        try
            bboxes = dlmread(fullfile(boxdir,chunkfiles{chunk_i}));
        catch
            bboxes = [];
        end
        
        for bbox_i = 1:1:size(bboxes,1)
            
            % DEBUG; REMOVE LATER
            if bbox_i ~= 4 && debug
                continue;
            end
            
            methods = {'df'}; %,'ccot'}; %,'staple','diagnose','kcf'};
            for mNum = 1:length(methods)
                method = methods{mNum};

                trackboxes = dlmread(fullfile(boxdir,sprintf('%s_%03d.track',chunk_name,bbox_i)));

                im_dists = zeros(size(trackboxes));
                
                has_not_run_before = true;
                
                for frame_i = minFrame:1:maxFrame
                    
                    if if_use_minus_something || has_not_run_before
                        % FOR FRAME TO COMPARE WITH
                        if ~if_use_minus_something || frame_i <= compare_past_by
                            prior_frame_index = 1;
                        else
                            prior_frame_index = frame_i - compare_past_by;
                        end

                        bbox_first = trackboxes(prior_frame_index,:);

                        frame_first = imread(fullfile(imDir,imFiles{minFrame+prior_frame_index-1}));
                        frame_first = padarray(frame_first, [pad,pad], 0, 'both');

                        x_first = bbox_first(1);
                        y_first = bbox_first(2);
                        w_first = bbox_first(3);
                        h_first = bbox_first(4);

                        x_first = x_first-floor(w_first/2) + pad;
                        y_first = y_first-floor(h_first/2) + pad;
                        w_first = 2*w_first;
                        h_first = 2*h_first;
                        % TODO Check if it crosses image boundary?

                        bbox_left_first = [x_first,y_first,floor(w_first/2),h_first];
                        bbox_right_first = [x_first+floor(w_first/2),y_first,floor(w_first/2),h_first];
                        bbox_up_first = [x_first,y_first,w_first,floor(h_first/2)];
                        bbox_down_first = [x_first,y_first+floor(h_first/2),w_first,floor(h_first/2)];
                        
                        has_not_run_before = false;
                    end

                    % FOR FRAME TO COMPARE (I.E. CURRENT)
                    bbox = trackboxes(frame_i-minFrame+1,:);
                    
                    frame = imread(fullfile(imDir,imFiles{frame_i-minFrame+1}));
                    frame = padarray(frame, [pad,pad], 0, 'both');
                    
                    x = bbox(1);
                    y = bbox(2);
                    w = bbox(3);
                    h = bbox(4);

                    % INCREASE BOX SIZE
                    x = x-floor(w/2) + pad;
                    y = y-floor(h/2) + pad;
                    w = 2*w;
                    h = 2*h;
                    % TODO Check if it crosses image boundary?

                    bbox_left = [x,y,floor(w/2),h];
                    bbox_right = [x+floor(w/2),y,floor(w/2),h];
                    bbox_up = [x,y,w,floor(h/2)];
                    bbox_down = [x,y+floor(h/2),w,floor(h/2)];

                    dist_left_l2 = calc_bbox_distance(bbox_left,bbox_left_first,frame,frame_first);
                    dist_right_l2 = calc_bbox_distance(bbox_right,bbox_right_first,frame,frame_first);
                    dist_up_l2 = calc_bbox_distance(bbox_up,bbox_up_first,frame,frame_first);
                    dist_down_l2 = calc_bbox_distance(bbox_down,bbox_down_first,frame,frame_first);
                    
                    im_dists(frame_i-minFrame+1, :) = [dist_left_l2, dist_right_l2, dist_up_l2, dist_down_l2];
                end
                
                dlmwrite(fullfile(boxdir,sprintf('%s_%03d.4boxdist',chunk_name,bbox_i)),im_dists);
            end
        end
    end
end


%% plot
if debug
    x = minFrame:1:maxFrame;

    plot(x,im_dists(:,1),'Color','r'); hold on;
    plot(x,im_dists(:,2),'Color','g'); hold on;
    plot(x,im_dists(:,3),'Color','b'); hold on;
    plot(x,im_dists(:,4),'Color','k');
end